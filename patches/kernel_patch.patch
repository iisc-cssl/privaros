diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/include/linux/msg.h privaros_kernel/include/linux/msg.h
--- kernel-4.9/include/linux/msg.h	2020-08-25 22:19:53.751717540 +0530
+++ privaros_kernel/include/linux/msg.h	2020-08-06 17:59:07.260455141 +0530
@@ -10,6 +10,7 @@
 	long m_type;
 	size_t m_ts;		/* message text size */
 	struct msg_msgseg *next;
+	int pid;
 	void *security;
 	/* the actual message follows immediately */
 };
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/include/linux/skbuff.h privaros_kernel/include/linux/skbuff.h
--- kernel-4.9/include/linux/skbuff.h	2020-08-25 22:19:53.775717541 +0530
+++ privaros_kernel/include/linux/skbuff.h	2020-08-06 17:59:07.360455141 +0530
@@ -40,6 +40,8 @@
 #include <linux/if_packet.h>
 #include <net/flow.h>
 
+
+
 /* The interface for checksum offload between the stack and networking drivers
  * is as follows...
  *
@@ -774,9 +776,9 @@
 		unsigned int	sender_cpu;
 	};
 #endif
-#ifdef CONFIG_NETWORK_SECMARK
+// #ifdef CONFIG_NETWORK_SECMARK
 	__u32		secmark;
-#endif
+// #endif
 
 	union {
 		__u32		mark;
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/include/uapi/linux/xattr.h privaros_kernel/include/uapi/linux/xattr.h
--- kernel-4.9/include/uapi/linux/xattr.h	2020-08-25 22:19:53.711717540 +0530
+++ privaros_kernel/include/uapi/linux/xattr.h	2020-08-06 17:59:06.708455141 +0530
@@ -52,6 +52,9 @@
 #define XATTR_SELINUX_SUFFIX "selinux"
 #define XATTR_NAME_SELINUX XATTR_SECURITY_PREFIX XATTR_SELINUX_SUFFIX
 
+#define XATTR_APPARMOR_SUFFIX "apparmor"
+#define XATTR_NAME_APPARMOR XATTR_SECURITY_PREFIX XATTR_APPARMOR_SUFFIX
+
 #define XATTR_SMACK_SUFFIX "SMACK64"
 #define XATTR_SMACK_IPIN "SMACK64IPIN"
 #define XATTR_SMACK_IPOUT "SMACK64IPOUT"
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/net/ipv4/tcp_ipv4.c privaros_kernel/net/ipv4/tcp_ipv4.c
--- kernel-4.9/net/ipv4/tcp_ipv4.c	2020-08-25 22:19:52.375717515 +0530
+++ privaros_kernel/net/ipv4/tcp_ipv4.c	2020-08-26 11:45:29.860614818 +0530
@@ -84,6 +84,21 @@
 #include <crypto/hash.h>
 #include <linux/scatterlist.h>
 
+#include "../../security/apparmor/include/apparmor.h"
+#include "../../security/apparmor/include/apparmorfs.h"
+#include "../../security/apparmor/include/audit.h"
+#include "../../security/apparmor/include/capability.h"
+#include "../../security/apparmor/include/context.h"
+#include "../../security/apparmor/include/domain.h"
+#include "../../security/apparmor/include/file.h"
+#include "../../security/apparmor/include/ipc.h"
+#include "../../security/apparmor/include/match.h"
+#include "../../security/apparmor/include/path.h"
+#include "../../security/apparmor/include/policy.h"
+#include "../../security/apparmor/include/procattr.h"
+#include "../../security/apparmor/include/resource.h"
+#include "../../security/apparmor/include/sid.h"
+
 int sysctl_tcp_tw_reuse __read_mostly;
 int sysctl_tcp_low_latency __read_mostly;
 
@@ -1401,6 +1416,30 @@
 {
 	struct sock *rsk;
 
+	//Custom code: start
+	char *curr_domain = NULL;
+	struct aa_profile *profile;
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	profile = aa_get_newest_profile(ctx->profile);
+	const struct tcphdr *tcpheader;
+	
+	if (profile != NULL && !unconfined(profile))
+	{
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+		if (curr_domain != NULL)
+		{
+			tcpheader = tcp_hdr(skb);
+			profile->pid = skb->secmark;
+			// printk (KERN_INFO "tcp_v4_do_rcv: pid %d restored from skb\n", profile->pid );
+			// printk (KERN_INFO "tcp_v4_do_rcv: TCP socket label_name: %s, profile->pid %d, profile->recv_pid %d, skb->pid %d, skb->data_len %d, syn = %d, ack = %d, fin = %d\n", profile->base.hname, profile->pid, profile->recv_pid, skb->secmark, skb->data_len, tcpheader->syn, tcpheader->ack, tcpheader->fin);
+		}
+	}
+	aa_put_profile(ctx->profile);
+	//Custom code: end
+
 	if (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */
 		struct dst_entry *dst = sk->sk_rx_dst;
 
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/net/ipv4/tcp_output.c privaros_kernel/net/ipv4/tcp_output.c
--- kernel-4.9/net/ipv4/tcp_output.c	2020-08-25 22:19:52.375717515 +0530
+++ privaros_kernel/net/ipv4/tcp_output.c	2020-08-26 11:46:52.356616350 +0530
@@ -42,6 +42,21 @@
 #include <linux/gfp.h>
 #include <linux/module.h>
 
+#include "../../security/apparmor/include/apparmor.h"
+#include "../../security/apparmor/include/apparmorfs.h"
+#include "../../security/apparmor/include/audit.h"
+#include "../../security/apparmor/include/capability.h"
+#include "../../security/apparmor/include/context.h"
+#include "../../security/apparmor/include/domain.h"
+#include "../../security/apparmor/include/file.h"
+#include "../../security/apparmor/include/ipc.h"
+#include "../../security/apparmor/include/match.h"
+#include "../../security/apparmor/include/path.h"
+#include "../../security/apparmor/include/policy.h"
+#include "../../security/apparmor/include/procattr.h"
+#include "../../security/apparmor/include/resource.h"
+#include "../../security/apparmor/include/sid.h"
+
 /* allow Tegra qdisc to restrict tcp rx datarate */
 #ifdef CONFIG_NET_SCH_TEGRA
 uint tcp_window_divisor = 1;
@@ -1064,6 +1079,30 @@
 	/* Cleanup our debris for IP stacks */
 	memset(skb->cb, 0, max(sizeof(struct inet_skb_parm),
 			       sizeof(struct inet6_skb_parm)));
+	
+	//Custom code: start
+	char *curr_domain = NULL;
+	struct aa_profile *profile;
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	profile = aa_get_newest_profile(ctx->profile);
+	const struct tcphdr *tcpheader;
+
+	if (profile != NULL && !unconfined(profile))
+	{
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+		if (curr_domain != NULL)
+		{
+			tcpheader = tcp_hdr(skb);
+			skb->secmark = profile->pid;
+			// printk (KERN_INFO "__tcp_transmit_skb: pid %d added to skb\n", profile->pid);
+			// printk (KERN_INFO "__tcp_transmit_skb: TCP socket label_name: %s, profile->pid %d, profile->recv_pid %d, skb->pid %d, skb->data_len %d, syn = %d, ack = %d, fin = %d\n", profile->base.hname, profile->pid, profile->recv_pid, skb->secmark, skb->data_len, tcpheader->syn, tcpheader->ack, tcpheader->fin);
+		}
+	}
+	aa_put_profile(ctx->profile);
+	//Custom code: end
 
 	err = icsk->icsk_af_ops->queue_xmit(sk, skb, &inet->cork.fl);
 
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/net/ipv4/udp.c privaros_kernel/net/ipv4/udp.c
--- kernel-4.9/net/ipv4/udp.c	2020-08-25 22:19:52.375717515 +0530
+++ privaros_kernel/net/ipv4/udp.c	2020-08-26 11:48:11.276617815 +0530
@@ -116,6 +116,21 @@
 #include <net/sock_reuseport.h>
 #include <net/addrconf.h>
 
+#include "../../security/apparmor/include/apparmor.h"
+#include "../../security/apparmor/include/apparmorfs.h"
+#include "../../security/apparmor/include/audit.h"
+#include "../../security/apparmor/include/capability.h"
+#include "../../security/apparmor/include/context.h"
+#include "../../security/apparmor/include/domain.h"
+#include "../../security/apparmor/include/file.h"
+#include "../../security/apparmor/include/ipc.h"
+#include "../../security/apparmor/include/match.h"
+#include "../../security/apparmor/include/path.h"
+#include "../../security/apparmor/include/policy.h"
+#include "../../security/apparmor/include/procattr.h"
+#include "../../security/apparmor/include/resource.h"
+#include "../../security/apparmor/include/sid.h"
+
 struct udp_table udp_table __read_mostly;
 EXPORT_SYMBOL(udp_table);
 
@@ -798,6 +813,27 @@
 	int len = skb->len - offset;
 	__wsum csum = 0;
 
+	//Custom code: start
+	char *curr_domain = NULL;
+	struct aa_profile *profile;
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	profile = aa_get_newest_profile(ctx->profile);
+	if (profile != NULL && !unconfined(profile))
+	{
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+		if (curr_domain != NULL)
+		{
+			skb->secmark = profile->pid;
+			// printk (KERN_INFO "udp_send_skb: pid %d added to skb\n", profile->pid);
+		}
+	}
+	aa_put_profile(ctx->profile);
+	//Custom code: end
+
+
 	/*
 	 * Create a UDP header
 	 */
@@ -1269,6 +1305,27 @@
 	if (!skb)
 		return err;
 
+	//Custom code: start
+	char *curr_domain = NULL;
+	struct aa_profile *profile;
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	profile = aa_get_newest_profile(ctx->profile);
+	if (profile != NULL && !unconfined(profile))
+	{
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+		if (curr_domain != NULL)
+		{
+			profile->pid = skb->secmark;
+			// printk (KERN_INFO "udp_recvmsg: pid %d restored from skb\n", profile->pid );
+		}
+	}
+	aa_put_profile(ctx->profile);
+	//Custom code: end
+
+
 	ulen = skb->len;
 	copied = len;
 	if (copied > ulen - off)
@@ -1506,6 +1563,28 @@
 	int rc;
 	int is_udplite = IS_UDPLITE(sk);
 
+	//Custom code: start
+	char *curr_domain = NULL;
+	struct aa_profile *profile;
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	profile = aa_get_newest_profile(ctx->profile);
+	if (profile != NULL && !unconfined(profile))
+	{
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+		if (curr_domain != NULL)
+		{
+			profile->pid = skb->secmark;
+			// printk (KERN_INFO "udp_queue_rcv_skb: pid %d restored from skb\n", profile->pid );
+		}
+	}
+	aa_put_profile(ctx->profile);
+	//Custom code: end
+
+
+
 	/*
 	 *	Charge it to the socket, dropping if the queue is full.
 	 */
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/domain.c privaros_kernel/security/apparmor/domain.c
--- kernel-4.9/security/apparmor/domain.c	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/domain.c	2020-08-06 20:11:09.252463666 +0530
@@ -30,6 +30,14 @@
 #include "include/path.h"
 #include "include/policy.h"
 
+#include <linux/namei.h>
+#include <linux/dcache.h>
+#include <linux/fs.h>
+#include <linux/crypto.h>
+#include <crypto/hash.h>
+#include <linux/string.h>
+
+
 /**
  * aa_free_domain_entries - free entries in a domain table
  * @domain: the domain table to free  (MAYBE NULL)
@@ -328,6 +336,92 @@
 	return new_profile;
 }
 
+
+
+
+struct sdesc {
+    struct shash_desc shash;
+    char ctx[];
+};
+
+static struct sdesc *init_sdesc(struct crypto_shash *alg)
+{
+    struct sdesc *sdesc;
+    int size;
+
+    size = sizeof(struct shash_desc) + crypto_shash_descsize(alg);
+    sdesc = kmalloc(size, GFP_KERNEL);
+    if (!sdesc)
+        return ERR_PTR(-ENOMEM);
+    sdesc->shash.tfm = alg;
+    return sdesc;
+}
+
+static int _calc_hash(struct crypto_shash *alg,
+             const unsigned char *data, unsigned int datalen,
+             unsigned char *digest)
+{
+    struct sdesc *sdesc;
+    int ret;
+
+    sdesc = init_sdesc(alg);
+    if (IS_ERR(sdesc)) {
+        pr_info("can't alloc sdesc\n");
+        return PTR_ERR(sdesc);
+    }
+
+    ret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);
+    kfree(sdesc);
+    return ret;
+}
+
+static int apparmor_permform_hash(const unsigned char *data, unsigned int datalen,
+             unsigned char *digest)
+{
+    struct crypto_shash *alg;
+	char *hash_alg_name = "sha1";
+    int ret;
+
+    alg = crypto_alloc_shash(hash_alg_name, CRYPTO_ALG_TYPE_SHASH, 0);
+    if (IS_ERR(alg)) {
+            pr_info("can't alloc alg %s\n", hash_alg_name);
+            return PTR_ERR(alg);
+    }
+    ret = _calc_hash(alg, data, datalen, digest);
+    crypto_free_shash(alg);
+    return ret;
+}
+
+bool apparmor_verify_binary_hash(char *path, char *req_hash)
+{
+    void *file_data_buf = NULL;
+	const unsigned int digest_size = 20;
+	unsigned char digest[digest_size];
+	unsigned char curr_hash[(2 * digest_size) + 1];
+    loff_t max_size = 0x1000000000000000, size = 0;
+	int i, ret;
+
+	ret = kernel_read_file_from_path(path, &file_data_buf, &size, max_size, READING_MODULE);
+    if(ret) 
+    {
+        return false;
+    }
+	ret = apparmor_permform_hash(file_data_buf, size, digest);
+    if(ret) {
+        return false;
+    }
+
+	for(i = 0; i < digest_size; i++) {
+		snprintf(&curr_hash[i * 2], sizeof(curr_hash)-(i*2),"%02X", digest[i]);
+	}
+
+	printk (KERN_INFO "Req hash=%s, curr_hash=%s\n", req_hash, curr_hash);
+    if(strncasecmp(curr_hash, req_hash, sizeof(curr_hash)) == 0)
+        return true;
+    
+    return false;
+}
+
 /**
  * apparmor_bprm_set_creds - set the new creds on the bprm struct
  * @bprm: binprm for the exec  (NOT NULL)
@@ -348,6 +442,7 @@
 	};
 	const char *name = NULL, *info = NULL;
 	int error = 0;
+	char *curr_domain = NULL;
 
 	if (bprm->cred_prepared)
 		return 0;
@@ -496,6 +591,30 @@
 	/* when transitioning profiles clear unsafe personality bits */
 	bprm->per_clear |= PER_CLEAR_ON_SETID;
 
+	if(new_profile != NULL && !unconfined(new_profile) )
+	{
+		//get the domain from current process profile and not from socket's profile, coz socket's can be passed
+		if(new_profile->current_domain != NULL && new_profile->current_domain->domain != NULL)
+        {
+            curr_domain = new_profile->current_domain->domain;
+        }
+		
+		if (curr_domain != NULL)
+		{
+			printk (KERN_INFO "[apparmor_bprm_set_creds] process =%s, domain=%s filename=%s, name=%s\n", current->comm, curr_domain, bprm->filename, name);
+			if(apparmor_verify_binary_hash(name, curr_domain))
+			{
+				
+			}
+			else
+			{
+				error = -EACCES;	
+			}
+			
+		}
+	}
+
+
 x_clear:
 	aa_put_profile(cxt->profile);
 	/* transfer new profile reference will be released when cxt is freed */
@@ -562,7 +681,6 @@
  */
 void apparmor_bprm_committed_creds(struct linux_binprm *bprm)
 {
-	/* TODO: cleanup signals - ipc mediation */
 	return;
 }
 
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/include/apparmor.h privaros_kernel/security/apparmor/include/apparmor.h
--- kernel-4.9/security/apparmor/include/apparmor.h	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/include/apparmor.h	2020-08-06 20:11:09.252463666 +0530
@@ -20,6 +20,45 @@
 
 #include "match.h"
 
+
+// Custom code: start
+// Headers for ioctl() interface
+#include <linux/module.h>	
+#include <linux/kernel.h>	
+#include <linux/init.h>		
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+typedef s64 tag_t;
+
+struct flag_struct
+{
+    int flag;
+};
+
+#define TASKCTXIO 'r'
+
+#define SET_NETWORK_FLAG _IO(TASKCTXIO, 0)
+#define CLEAR_NETWORK_FLAG _IO(TASKCTXIO, 1)
+#define SET_FILE_FLAG _IO(TASKCTXIO, 2)
+#define CLEAR_FILE_FLAG _IO(TASKCTXIO, 3)
+#define SET_MSGQ_FLAG _IO(TASKCTXIO, 4)
+#define CLEAR_MSGQ_FLAG _IO(TASKCTXIO, 5)
+#define SET_SHM_FLAG _IO(TASKCTXIO, 6)
+#define CLEAR_SHM_FLAG _IO(TASKCTXIO, 7)
+#define SET_GRAPHGEN_FLAG _IO(TASKCTXIO, 8)
+#define CLEAR_GRAPHGEN_FLAG _IO(TASKCTXIO, 9)
+
+// Custom code: end
+
+
+
+
 /*
  * Class of mediation types in the AppArmor policy db
  */
@@ -62,6 +101,7 @@
 
 /* Flag indicating whether initialization completed */
 extern int apparmor_initialized __initdata;
+extern int apparmor_ioctl_debug;
 
 /* fn's in lib */
 char *aa_split_fqname(char *args, char **ns_name);
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/include/context.h privaros_kernel/security/apparmor/include/context.h
--- kernel-4.9/security/apparmor/include/context.h	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/include/context.h	2020-08-06 20:11:09.252463666 +0530
@@ -23,6 +23,25 @@
 
 #define cred_cxt(X) (X)->security
 #define current_cxt() cred_cxt(current_cred())
+#define SK_CTX(X) ((X)->sk_security)
+
+struct aa_sk_ctx {
+	struct aa_profile *profile;
+};
+
+struct aa_msg_queue_ctx {
+	struct aa_profile *profile;
+};
+
+struct aa_inode_ctx {
+	struct aa_profile *profile;
+};
+
+
+struct aa_shm_ctx {
+	struct aa_profile *profile;
+	struct list_head proc_attach_list;
+};
 
 /* struct aa_file_cxt - the AppArmor context the file was opened in
  * @perms: the permission the file was opened with
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/include/file.h privaros_kernel/security/apparmor/include/file.h
--- kernel-4.9/security/apparmor/include/file.h	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/include/file.h	2020-08-06 20:11:09.252463666 +0530
@@ -25,6 +25,12 @@
  * We use MAY_EXEC, MAY_WRITE, MAY_READ, MAY_APPEND and the following flags
  * for profile permissions
  */
+
+#define AA_MAY_EXEC		MAY_EXEC
+#define AA_MAY_WRITE		MAY_WRITE
+#define AA_MAY_READ		MAY_READ
+#define AA_MAY_APPEND		MAY_APPEND
+
 #define AA_MAY_CREATE                  0x0010
 #define AA_MAY_DELETE                  0x0020
 #define AA_MAY_META_WRITE              0x0040
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/include/policy.h privaros_kernel/security/apparmor/include/policy.h
--- kernel-4.9/security/apparmor/include/policy.h	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/include/policy.h	2020-08-06 20:11:09.252463666 +0530
@@ -156,6 +156,29 @@
 	struct aa_profile __rcu *profile;
 };
 
+//Custom code: start
+struct ListOfDomains
+{
+	char *domain;
+	struct list_head domain_list;
+};
+
+
+struct DomainMetaData
+{
+	char *domain;
+	int allow_cnt;
+	int deny_cnt;
+	int ip_allow_cnt;
+};
+
+struct ListOfIPAddrs 
+{
+	u32 ip_addr;
+	struct list_head ip_addr_list;
+};
+//Custom code: end
+
 
 /* struct aa_profile - basic confinement data
  * @base - base components of the profile (name, refcount, lists, lock ...)
@@ -214,6 +237,16 @@
 	u32 path_flags;
 	int size;
 
+	/*
+	 * Custom fields
+	 */
+	u32 pid;
+	u32 recv_pid;
+	struct DomainMetaData *current_domain;
+	struct ListOfDomains *allow_net_domains;
+	struct ListOfIPAddrs *allowed_ip_addrs;
+	char *is_trusted;
+
 	struct aa_policydb policy;
 	struct aa_file_rules file;
 	struct aa_caps caps;
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/lsm.c privaros_kernel/security/apparmor/lsm.c
--- kernel-4.9/security/apparmor/lsm.c	2020-08-26 12:01:03.644632152 +0530
+++ privaros_kernel/security/apparmor/lsm.c	2020-08-26 11:55:45.876626253 +0530
@@ -36,8 +36,255 @@
 #include "include/policy.h"
 #include "include/procattr.h"
 
+
+#include <net/af_unix.h>
+#include <linux/skbuff.h>
+#include <net/inet_sock.h>
+#include <linux/inetdevice.h>
+#include <linux/tcp.h>
+#include <uapi/linux/tcp.h>
+#include <linux/xattr.h>
+#include <uapi/linux/xattr.h>
+#include <linux/msg.h>
+#include <linux/stat.h>
+
 /* Flag indicating whether initialization completed */
 int apparmor_initialized __initdata;
+int apparmor_ioctl_debug = 99;
+
+
+
+#define MAX_LABEL_CACHE_SIZE 20
+struct profile_cache
+{
+	pid_t pid;
+	struct aa_profile *cur_profile;
+
+}profile_cache_arr[MAX_LABEL_CACHE_SIZE];
+
+static int apparmor_tsk_container_add(struct aa_profile *profile, pid_t pid)
+{
+	int ret = 0, i;
+	static int remove_idx = 0;
+	for(i = 0; i < MAX_LABEL_CACHE_SIZE; i++)
+	{
+		if(profile_cache_arr[i].pid == pid)
+		{
+			ret = 1;
+			break;
+		}
+		else if (profile_cache_arr[i].pid == 0)
+		{
+			profile_cache_arr[i].pid = pid;
+			profile_cache_arr[i].cur_profile = aa_get_newest_profile(profile);
+			ret = 1;
+			break;
+		}
+	}
+	if (ret == 0)
+	{
+		// printk (KERN_INFO "apparmor_tsk_container_add: adding data at idx %d, pid %d, profile %s\n", remove_idx, pid, profile->hname);
+		
+		profile_cache_arr[remove_idx].pid = pid;
+		profile_cache_arr[remove_idx].cur_profile = aa_get_newest_profile(profile);
+		remove_idx += 1;
+		remove_idx %= MAX_LABEL_CACHE_SIZE;
+	}
+	else
+	{
+		// printk (KERN_INFO "apparmor_tsk_container_add: adding data at idx %d, pid %d, profile %s\n", i, pid, profile->hname);
+	}
+	
+	return ret;	
+}
+
+static struct aa_profile *apparmor_tsk_container_get(pid_t pid)
+{
+	struct aa_profile *ret = NULL;
+	int i;
+	for(i = 0; i < MAX_LABEL_CACHE_SIZE; i++)
+	{
+		if (profile_cache_arr[i].pid == pid && profile_cache_arr[i].cur_profile != NULL)
+		{
+			ret = aa_get_newest_profile(profile_cache_arr[i].cur_profile);
+			break;
+		}
+	}
+	if (ret != NULL)
+	{
+		// printk (KERN_INFO "apparmor_tsk_container_get: data found at idx %d, pid %d, profile %s\n", i, pid, ret->base.hname);
+	}
+	else
+	{
+		// printk (KERN_INFO "apparmor_tsk_container_get: data not found for pid %d\n", pid);
+	}
+	return ret;
+}
+
+static int apparmor_tsk_container_remove(pid_t pid)
+{
+	int ret = 0, i;
+	for(i = 0; i < MAX_LABEL_CACHE_SIZE; i++)
+	{
+		if(profile_cache_arr[i].pid == pid)
+		{
+			// printk (KERN_INFO "apparmor_tsk_container_get: data removed at idx %d, pid %d, profile %s\n", i, pid, profile_cache_arr[i].cur_profile->base.hname);
+			profile_cache_arr[i].pid = 0;
+			aa_put_profile(profile_cache_arr[i].cur_profile);
+
+			profile_cache_arr[i].cur_profile = NULL;
+			ret = 1;
+		}
+	}
+	return ret;	
+}
+static int apparmor_extract_daddr(struct msghdr *msg, struct sock *sk)
+{
+	struct inet_sock *inet;
+	u32 daddr = 0;
+	DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
+	inet = inet_sk(sk);
+		
+	if (usin) 
+	{
+		if (msg->msg_namelen < sizeof(*usin))
+			return -EINVAL;
+		if (usin->sin_family != AF_INET) 
+		{
+			if (usin->sin_family != AF_UNSPEC)
+				return -EAFNOSUPPORT;
+		}
+
+		daddr = usin->sin_addr.s_addr;
+	} 
+	else 
+	{
+		if (sk->sk_state != TCP_ESTABLISHED)
+			return -EDESTADDRREQ;
+		daddr = inet->inet_daddr;
+	}
+	return daddr;
+}
+
+int localhost_address(u32 ip_addr)
+{
+	struct net_device *dev;
+	u32 dev_addr;
+	if((ip_addr & 0x000000FF) == 127)
+	{
+		if(apparmor_ioctl_debug == 0)
+			printk(KERN_INFO "localhost_address: Packet from localhost: %pi4\n", &ip_addr);
+		return 1;
+	}
+
+	read_lock(&dev_base_lock);
+	dev = first_net_device(&init_net);
+	while (dev) 
+	{
+		dev_addr = inet_select_addr(dev, 0, RT_SCOPE_UNIVERSE);
+		if(dev_addr == ip_addr)
+		{
+			if(apparmor_ioctl_debug == 0)
+				printk(KERN_INFO "localhost_address: IP address %pi4 equals device IP addr %pi4\n", &ip_addr, &dev_addr);
+			read_unlock(&dev_base_lock);
+			return 1;
+		}
+		dev = next_net_device(dev);
+	}
+	read_unlock(&dev_base_lock);
+
+	return 0;
+	
+}
+
+static bool apparmor_check_for_flow (struct aa_profile *profile, char *checking_domain)
+{
+	struct ListOfDomains *iterator;
+	if (profile->allow_net_domains)
+	{
+		list_for_each_entry(iterator, &(profile->allow_net_domains->domain_list), domain_list)
+		{
+			if(apparmor_ioctl_debug % 2 == 0)
+				printk (KERN_INFO "apparmor_check_for_flow: Matching between %s, %s\n", iterator->domain, checking_domain);
+			if ((strcmp(iterator->domain, checking_domain) == 0) || strcmp(iterator->domain, "*") == 0)
+			{
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+static struct aa_profile *apparmor_socket_label_compare_helper(__u32 pid)
+{
+	struct task_struct *task_data;
+	struct aa_profile *ret = NULL;
+	task_data = get_pid_task(find_get_pid(pid), PIDTYPE_PID);
+	if (task_data == NULL)
+	{
+		ret = apparmor_tsk_container_get(pid);
+	}
+	else
+	{
+		ret = aa_get_newest_profile(aa_cred_profile(__task_cred(task_data)));
+	}
+	return ret;
+}
+static bool apparmor_socket_label_compare(__u32 sender_pid, __u32 receiver_pid)
+{
+	bool allow = true;		
+	struct aa_profile *sender_profile, *receiver_profile;
+	char *receiver_domain = NULL;
+	
+	if (sender_pid != receiver_pid && sender_pid != 0 && receiver_pid != 0)
+	{
+		allow = false;
+		sender_profile = apparmor_socket_label_compare_helper(sender_pid);
+		receiver_profile = apparmor_socket_label_compare_helper(receiver_pid);
+		
+		if (sender_profile != NULL && receiver_profile != NULL)
+		{
+			if (receiver_profile->current_domain != NULL && receiver_profile->current_domain->domain != NULL)
+			{
+				receiver_domain = receiver_profile->current_domain->domain;
+			}
+			if (receiver_domain != NULL)
+			{
+				allow = apparmor_check_for_flow(sender_profile, receiver_domain);
+				if (allow)
+				{
+					if(apparmor_ioctl_debug == 8)
+						printk (KERN_INFO "[GRAPH_GEN] Process %s, socket_ipc, %s\n", sender_profile->base.hname, receiver_profile->base.hname);
+				}
+				
+			}
+			if(apparmor_ioctl_debug == 0)
+				printk (KERN_INFO "apparmor_socket_label_compare: receiver process = %s, pid = %d, sent from process %s, pid = %d, Match is %d\n", receiver_profile->base.hname, receiver_pid, sender_profile->base.hname, sender_pid, allow);
+		
+		}
+		
+	}
+	return allow;
+}
+
+static bool apparmor_domain_declassify (struct aa_profile *profile, u32 check_ip_addr)
+{
+	struct ListOfIPAddrs *iterator;
+	if (profile->allowed_ip_addrs)
+	{
+		list_for_each_entry(iterator, &(profile->allowed_ip_addrs->ip_addr_list), ip_addr_list)
+		{
+			if(apparmor_ioctl_debug % 2 == 0)
+				printk (KERN_INFO "apparmor_domain_declassify: Matching between %u, %u\n", iterator->ip_addr, check_ip_addr);
+			if (iterator->ip_addr == 0 || iterator->ip_addr == check_ip_addr)
+			{
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
 
 /*
  * LSM hook functions
@@ -340,6 +587,32 @@
 	return common_perm_path(OP_GETATTR, path, AA_MAY_META_READ);
 }
 
+static int apparmor_inode_alloc_security(struct inode *inode)
+{
+	struct aa_inode_ctx *ctx;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	
+	ctx->profile = aa_get_task_profile(current);
+	inode->i_security = ctx;
+
+	// printk(KERN_INFO "inode_alloc_security: process = %s, profile = %s\n", current->comm, ctx->profile->base.hname);
+
+
+	return 0;
+}
+static void apparmor_inode_free_security(struct inode *inode)
+{
+	struct aa_inode_ctx *ctx = inode->i_security;
+
+	inode->i_security = NULL;
+	aa_put_profile(ctx->profile);
+	kfree(ctx);	
+
+}
+
 static int apparmor_file_open(struct file *file, const struct cred *cred)
 {
 	struct aa_file_cxt *fcxt = file->f_security;
@@ -386,7 +659,7 @@
 static void apparmor_file_free_security(struct file *file)
 {
 	struct aa_file_cxt *cxt = file->f_security;
-
+	
 	aa_free_file_context(cxt);
 }
 
@@ -418,9 +691,338 @@
 	return error;
 }
 
+bool apparmor_check_domain_in_xattrs(char *domain, char *xattr_buf)
+{
+	bool present = false;
+
+	char *found;
+
+    while( (found = strsep(&xattr_buf,",")) != NULL )
+	{
+		if(strcmp(domain, found) == 0)
+		{
+			present = true;
+			break;
+		}
+	}
+        
+	return present;
+}
+
+static int apparmor_calc_context_len(struct aa_profile *profile, int *context_len)
+{
+	struct ListOfDomains *iterator;
+	if (profile->allow_net_domains)
+	{
+		list_for_each_entry(iterator, &(profile->allow_net_domains->domain_list), domain_list)
+		{
+			*context_len += strlen(iterator->domain) + 1;
+		}
+	}
+	return 0;
+}
+
+static int apparmor_create_context(struct aa_profile *profile, char **context)
+{
+	struct ListOfDomains *iterator;
+	if (profile->allow_net_domains)
+	{
+		list_for_each_entry(iterator, &(profile->allow_net_domains->domain_list), domain_list)
+		{
+			*context = strcat(*context, iterator->domain);
+			*context = strcat(*context, ",");
+		}
+	}
+	return 0;
+}
+
+static void apparmor_setxattr(struct file *file, char *curr_domain)
+{
+	struct dentry *dentry = file->f_path.dentry;
+	struct aa_profile *curr_profile;
+	char *context = NULL;
+	int context_len = 0;
+
+	context_len += strlen(curr_domain) + 1;
+
+	curr_profile = aa_get_task_profile(current);
+	apparmor_calc_context_len(curr_profile, &context_len);
+	
+	
+	context = kzalloc(context_len + 1, GFP_KERNEL);
+	context = strcat(context, curr_domain);
+	context = strcat(context, ",");
+	apparmor_create_context(curr_profile, &context);
+
+	aa_put_profile(curr_profile);
+
+	context[context_len] = '\0';
+
+	if(apparmor_ioctl_debug == 2)
+		printk(KERN_INFO "apparmor_file_permission (%s): setting xattrs of file %s to %s\n", current->comm, file->f_path.dentry->d_iname, context);
+
+
+	__vfs_setxattr_noperm(dentry, XATTR_NAME_APPARMOR, context, context_len, 0);
+}
+
+static char *apparmor_get_domain_from_xattrs(char *context)
+{
+	char *found;
+	found = strsep(&context,",");
+	return found;
+}
+
 static int apparmor_file_permission(struct file *file, int mask)
 {
-	return common_file_perm(OP_FPERM, file, mask);
+	#define INITCONTEXTLEN 255
+
+	struct aa_profile *curr_profile;
+	char *curr_domain = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *inode = file->f_path.dentry->d_inode;
+	char *context;
+	int len = 0;
+	int rc = 0;
+	uid_t uid = inode->i_uid.val;
+	uid_t euid = current->cred->euid.val;
+	
+
+
+	int aa_perm = 0;
+
+	// First perform AppArmor MAC checks
+	// Only if MAC policy allows operation on the file do we perform xattr operations
+
+	aa_perm = common_file_perm(OP_FPERM, file, mask);
+
+
+		
+	if(uid == 0 || euid == 0 )
+	{
+		return 0;
+	}
+
+	
+
+	if(aa_perm == 0 && dentry != NULL)
+	{
+		//perform our additional xattr work if MAC checks succeed
+		curr_profile = aa_get_task_profile(current);
+		if (curr_profile != NULL)
+		{
+			if(curr_profile->current_domain != NULL && curr_profile->current_domain->domain != NULL)
+			{
+				curr_domain = curr_profile->current_domain->domain;
+			}
+			if(curr_domain)
+			{
+				char *tmppath = kzalloc(300, GFP_KERNEL);
+				if (tmppath != NULL)
+				{
+					// char *fullpath = dentry_path_raw(dentry, tmppath, 300);
+					char *fullpath = d_path(&file->f_path, tmppath, 300);
+					
+					if(apparmor_ioctl_debug == 8)
+					{
+						if (mask == AA_MAY_EXEC)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, exec_file, %s\n", curr_profile->base.hname, fullpath);
+						else if (mask ==  AA_MAY_WRITE)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, write_file, %s\n", curr_profile->base.hname, fullpath);
+						else if (mask ==  AA_MAY_READ)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, read_file, %s\n", curr_profile->base.hname, fullpath);
+						else if (mask ==  AA_MAY_APPEND)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, append_file, %s\n", curr_profile->base.hname, fullpath);
+						else if (mask ==  AA_MAY_CREATE)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, create_file, %s\n", curr_profile->base.hname, fullpath);
+						else if (mask ==  AA_MAY_DELETE)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, delete_file, %s\n", curr_profile->base.hname, fullpath);
+						// else if (mask ==  AA_MAY_RENAME)
+						// 	printk (KERN_INFO "[GRAPH_GEN] Process %s, rename_file, %s\n", curr_profile->base.hname, fullpath);
+					}
+					
+					
+					kzfree(tmppath);
+				}
+					
+				
+				// Code to retrieve xattr borrowed from SELinux hooks.c - function inode_doinit_use_xattr()
+
+				len = INITCONTEXTLEN;
+				context = kmalloc(len + 1, GFP_NOFS);
+				rc = __vfs_getxattr(dentry, inode, XATTR_NAME_APPARMOR, context, len);
+
+				if(mask == AA_MAY_READ)
+				{
+					if (S_ISFIFO(inode->i_mode))
+					{
+						//perform checing
+						struct aa_inode_ctx *ctx = inode->i_security;
+						struct aa_profile *ctx_profile = aa_get_newest_profile(ctx->profile);
+						if (ctx_profile)
+						{
+							if(apparmor_ioctl_debug == 2)
+								printk (KERN_INFO "file_permission: PIPE read: process = %s, label = %s\n", current->comm,ctx_profile->base.hname);
+							if(!apparmor_check_for_flow(ctx_profile, curr_domain))
+							{
+								aa_perm = -EPERM;
+								if(apparmor_ioctl_debug == 2)
+									printk ("file_permission: PIPE read: DENIED!\n");
+								goto file_permission_end;
+							}
+
+						}
+						else
+						{
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "file_permission: PIPE read: process = %s, label = NULL\n", current->comm);
+						}
+						
+					}
+					else if(rc > 0)
+					{
+						// Process with domain trying to read from a file with xattrs set - perform the check
+						if(apparmor_check_domain_in_xattrs(curr_domain, context))
+						{
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): process with domain %s ALLOW read from file %s\n", current->comm, curr_domain, file->f_path.dentry->d_iname);
+							aa_perm = 0;
+							goto file_permission_end;
+						}
+						else
+						{
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): process with domain %s DENY read from file %s\n", current->comm, curr_domain, file->f_path.dentry->d_iname);
+							aa_perm = -EPERM;
+							goto file_permission_end;
+						}
+						
+					}
+					else
+					{
+						if (rc == -ENODATA || rc == -EOPNOTSUPP || rc == 0) 
+						{
+							// The file has no xattrs set - ALLOW READ
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): process with domain %s ALLOW read from file %s - no xattrs set\n", current->comm, curr_domain, file->f_path.dentry->d_iname);
+							aa_perm = 0;
+							goto file_permission_end;
+						}
+						else
+						{
+							// Error while trying to get xattrs from file - return error code
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): Error -%d while trying to get xattrs from file %s \n", current->comm, rc, file->f_path.dentry->d_iname);
+							aa_perm = rc;
+							goto file_permission_end;
+						}
+					}
+					
+					
+				}//end of if(mask == AA_MAY_READ)
+
+				else if(mask == AA_MAY_WRITE)
+				{
+					if (S_ISFIFO(inode->i_mode))
+					{
+						//add profile to security
+						struct aa_inode_ctx *ctx = inode->i_security;
+						struct aa_profile *ctx_profile = aa_get_newest_profile(ctx->profile);
+						if (ctx_profile)
+						{
+							if(apparmor_check_for_flow(ctx_profile, curr_domain))
+							{
+								//put the old profile
+								aa_put_profile(ctx_profile);
+								//add new profile
+								ctx->profile = aa_get_newest_profile(curr_profile);
+								if(apparmor_ioctl_debug == 2)
+									printk (KERN_INFO "file_permission: PIPE write: profile updated!\n");
+							}
+							//TODO! clear data of pipe
+							if(apparmor_ioctl_debug == 2)
+								printk (KERN_INFO "file_permission: PIPE write: process = %s, label = 	%s\n", current->comm, ctx->profile->base.hname);
+							
+						}
+						else
+						{
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "file_permission: PIPE write: process = %s, label = NULL\n", current->comm);
+						}
+						
+					}
+					else if(rc > 0)
+					{
+						// The file has extended attributes stored
+
+						// Process with domain trying to write to an already labeled file
+						// Here, we must check whether the writing process is the same one that wrote to it first
+						// If so, check whether the file's label is stale and in this case update it. Finally ALLOW the operation
+						// If not, deny the operation because every file will only contain the data of the process that 
+						// first writes to it
+						char *file_domain = apparmor_get_domain_from_xattrs(context);
+						if(strcmp(file_domain, curr_domain) == 0)
+						{
+							// Process is the same one that wrote to it first - update the file's label and allow write
+							//??Maybe we need to track all files so that we can remove it when label changes??
+							inode_lock(inode);
+							apparmor_setxattr(file, curr_domain);
+							inode_unlock(inode);
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): writing to file %s with NEW XATTRS UPDATED. \n", current->comm, file->f_path.dentry->d_iname);
+							aa_perm = 0;
+							goto file_permission_end;
+						}
+						else
+						{
+							// Process is the different from the one that wrote to it first - DENY
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): DENIED UPDATED! setting xattrs of file %s to %s\n", current->comm, file->f_path.dentry->d_iname, context);
+							aa_perm = -EPERM;
+							goto file_permission_end;
+						}
+						
+						
+					}
+					else
+					{
+						if (rc == -ENODATA || rc == -EOPNOTSUPP || rc == 0) 
+						{
+							// The file has no extended attributes stored
+							// Process with a domain trying to write for the first time to a file without xattrs.
+							// We set the xattrs of a file to contain the allow_list of the first process that writes to it
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): process with domain %s trying to write for the first time to file %s without xattrs\n", current->comm, curr_domain, file->f_path.dentry->d_iname);
+							inode_lock(inode);
+							apparmor_setxattr(file, curr_domain);
+							inode_unlock(inode);
+						}
+						else
+						{
+							// Error while trying to get xattrs from file - return error code
+							if(apparmor_ioctl_debug == 2)
+								printk(KERN_INFO "apparmor_file_permission (%s): Error -%d while trying to get xattrs from file %s \n", current->comm, rc, file->f_path.dentry->d_iname);
+							aa_perm = rc;
+							goto file_permission_end;
+						}
+					}
+							
+					
+				}//end of else if(mask == AA_MAY_WRITE)
+			}
+
+			file_permission_end:
+			aa_put_profile(curr_profile);
+		}//end of curr_label != NUL
+		
+
+		
+
+		
+	}
+
+	
+
+	return aa_perm;
 }
 
 static int apparmor_file_lock(struct file *file, unsigned int cmd)
@@ -584,6 +1186,783 @@
 	return error;
 }
 
+
+static int apparmor_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
+{
+	struct aa_sk_ctx *ctx;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	SK_CTX(sk) = ctx;
+
+	return 0;
+}
+
+static void apparmor_sk_free_security(struct sock *sk)
+{
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+
+	SK_CTX(sk) = NULL;
+	aa_put_profile(ctx->profile);
+	kfree(ctx);	
+}
+
+
+static void apparmor_sk_clone_security(const struct sock *sk, struct sock *newsk)
+{
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_sk_ctx *new = SK_CTX(newsk);
+
+	new->profile = aa_get_profile(ctx->profile);
+}
+
+/**
+ * apparmor_socket_post_create - setup the per-socket security struct
+ *
+ * Note:
+ * -   kernel sockets currently labeled unconfined but we may want to
+ *     move to a special kernel label
+ * -   socket may not have sk here if created with sock_create_lite or
+ *     sock_alloc. These should be accept cases which will be handled in
+ *     sock_graft.
+ */
+static int apparmor_socket_post_create(struct socket *sock, int family,
+				       int type, int protocol, int kern)
+{
+	struct aa_profile *profile;
+
+	if (kern) {
+		// struct aa_ns *ns = aa_get_current_ns();
+
+		// label = aa_get_label(ns_unconfined(ns));
+		// aa_put_ns(ns);
+
+		struct aa_namespace *ns = aa_get_namespace((aa_current_profile())->ns);
+		profile = aa_get_profile(ns->unconfined);
+		aa_put_namespace(ns);
+
+	} 
+	else
+	{
+		struct aa_profile *old_profile = aa_get_task_profile(current);
+		profile = aa_get_newest_profile(old_profile);
+		aa_put_profile(old_profile);
+	}
+
+	if (sock->sk) {
+		struct aa_sk_ctx *ctx = SK_CTX(sock->sk);
+
+		aa_put_profile(ctx->profile);
+		ctx->profile = aa_get_profile(profile);
+	}
+	aa_put_profile(profile);
+
+	// if(family == AF_UNIX || family == AF_LOCAL) {
+	// 	printk(KERN_INFO "post_create: unix_socket for process %s\n", current->comm);
+	// }
+
+	return 0;
+}
+
+
+
+/**
+ * apparmor_socket_sendmsg - check perms before sending msg to another socket
+ */
+static int apparmor_socket_sendmsg(struct socket *sock,
+				   struct msghdr *msg, int size)
+{
+	struct sock *sk = sock->sk;
+    struct aa_profile *curr_profile;
+    struct aa_profile *curr_sock_profile;
+    struct aa_sk_ctx *ctx = SK_CTX(sk);
+    char *curr_domain = NULL;
+	bool allow = true;
+    u32 daddr = 0;
+	
+	struct aa_profile *old_profile = aa_get_task_profile(current);
+	curr_profile = aa_get_newest_profile(old_profile);
+	aa_put_profile(old_profile);
+	if(curr_profile != NULL && !unconfined(curr_profile) && ctx != NULL && ctx->profile != NULL)
+	{
+		curr_sock_profile = aa_get_newest_profile(ctx->profile);
+		
+		//reset the recv_pid
+		if (curr_sock_profile->pid != current->pid)
+		{
+			curr_sock_profile->recv_pid = 0;
+		}
+		curr_sock_profile->pid = current->pid;
+
+		//get the domain from current process profile and not from socket's profile, coz socket's can be passed
+		if(curr_profile->current_domain != NULL && curr_profile->current_domain->domain != NULL)
+        {
+            curr_domain = curr_profile->current_domain->domain;
+        }
+		
+		if (curr_domain != NULL)
+		{
+			if(apparmor_ioctl_debug == 0)
+				printk(KERN_INFO "sendmsg: process %s, label: %s\n", current->comm, curr_profile->base.hname);
+			apparmor_tsk_container_add(curr_profile, current->pid);
+			// printk (KERN_INFO "apparmor_socket_sendmsg (%s): current_pid = %d, sk_family=%d, sock->type=%d\n", current->comm, current->pid, sock->sk->sk_family, sock->type);
+			if(sk->sk_family == AF_INET)
+			{
+				allow = false;
+				int tmp = apparmor_extract_daddr(msg, sk);
+				if (tmp > 0)
+					daddr = tmp;
+				else
+				{
+					if(apparmor_ioctl_debug == 0)
+						printk (KERN_INFO "apparmor_socket_sendmsg: unable to get destination address\n");
+					goto sendmsg_out;
+				}
+				
+				// 1. Check if packet destination is localhost
+				if(localhost_address(daddr))
+				{
+					allow = true;
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "apparmor_socket_sendmsg (%s): Packet from localhost to localhost allowed, current_pid = %d\n", current->comm, current->pid);
+				}
+				
+
+				// 2. Check if packet destination is DDS multicast address
+				else if(ntohs(daddr) == 61439)
+				{
+					allow = true;
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "apparmor_socket_sendmsg (%s): DDS Multicast allowed %pi4, current_pid = %d\n", current->comm, &daddr, current->pid);
+				}
+
+				// 3. Check if destination address is multicast address
+				else if(((daddr & 0x000000FF) >= 224) && ((daddr & 0x000000FF) <= 239))
+				{
+					allow = true;
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "apparmor_socket_sendmsg (%s): Multicast address allowed %pi4, current_pid = %d\n", current->comm, &daddr, current->pid);
+				}
+				
+				/* 
+				* 4. Otherwise, the packet's destination is outside the machine
+				* Perform domain declassification by obtaining the list of allowed domains
+				* for the sending process
+				*/
+				else
+				{
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "apparmor_socket_sendmsg: Message from process %s to outside address %pi4, addr = %u, ntohs(addr) = %u, daddr & 0xFF000000 = %u, ntohs(daddr) & 0xFF000000 = %u, addr & 0x000000FF = %u, ntohs(daddr) & 0x000000FF = %u\n", current->comm, &daddr, daddr, ntohs(daddr), daddr & 0xFF000000, ntohs(daddr) & 0xFF000000, daddr & 0x000000FF, ntohs(daddr) & 0x000000FF);					
+
+                    allow = apparmor_domain_declassify(curr_profile, daddr);
+					if(allow)
+					{
+						if(apparmor_ioctl_debug == 8)
+							printk (KERN_INFO "[GRAPH_GEN] Process %s, network, %pi4\n", curr_profile->base.hname, &daddr);
+					}
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "apparmor_socket_sendmsg (%s): Domain declassification for message from process %s(pid = %d) to address %pi4, flow is %d\n", current->comm, current->comm, current->pid, &daddr, allow);
+				}				
+				
+			}//end of if(sk->sk_family == AF_INET)
+			else if(sk->sk_family == AF_UNIX || sk->sk_family == AF_LOCAL)
+			{
+				const struct cred *peer_cred = sk->sk_peer_cred;
+				char *peer_domain = NULL;
+				if(peer_cred)
+				{
+					struct aa_profile *peer_profile = aa_get_newest_profile(aa_cred_profile(peer_cred));
+					if(peer_profile && !unconfined(peer_profile))
+					{
+						allow = false;
+						if(apparmor_ioctl_debug == 0)
+							printk(KERN_INFO "sendmsg: unix_socket - curr_sock_label=%s, peer_label=%s\n", curr_sock_profile->base.hname, peer_profile->base.hname);
+
+						if(curr_sock_profile->current_domain != NULL && curr_sock_profile->current_domain->domain != NULL)
+						{
+							curr_domain = curr_sock_profile->current_domain->domain;
+						}
+						if(peer_profile->current_domain != NULL && peer_profile->current_domain->domain != NULL)
+						{
+							peer_domain = peer_profile->current_domain->domain;
+						}
+						if (curr_domain && peer_domain)
+						{
+							allow = apparmor_check_for_flow(curr_sock_profile, peer_domain);
+							if(allow)
+							{
+								if(apparmor_ioctl_debug == 0)
+									printk (KERN_INFO "sendmsg: unix_socket - flow from sender_domain %s to recv_domain %s is allowed\n", curr_domain, peer_domain);
+							}
+							else
+							{
+								if(apparmor_ioctl_debug == 0)
+									printk (KERN_INFO "sendmsg: unix_socket - flow from sender_domain %s to recv_domain %s is not allowed\n", curr_domain, peer_domain);
+							}
+						}
+						else
+						{
+							if(apparmor_ioctl_debug == 0)
+								printk (KERN_INFO "sendmsg: unix_socket - peer domain is NULL\n");
+						}
+						aa_put_profile(peer_profile);
+					}
+					else
+					{
+						if(apparmor_ioctl_debug == 0)
+							printk(KERN_INFO "sendmsg: unix_socket - peer profile is NULL\n");
+					}	
+				}
+				else
+				{
+					if(apparmor_ioctl_debug == 0)
+						printk(KERN_INFO "sendmsg: unix_socket - peer cred is NULL\n");
+				}
+				
+			}
+			
+			
+			
+		
+		}//end if (curr_domain != NULL)
+		
+		
+		sendmsg_out:
+		aa_put_profile(curr_sock_profile);
+		
+	}
+	
+	
+
+	aa_put_profile(curr_profile);
+	if (!allow)
+	{
+		if(apparmor_ioctl_debug == 0)
+			printk (KERN_INFO "sendmsg (%s): return is -13\n", current->comm);
+		return -EACCES;
+	}
+	
+    return 0;
+}
+
+
+
+/**
+ * apparmor_socket_recvmsg - check perms before receiving a message
+ */
+static int apparmor_socket_recvmsg(struct socket *sock,
+				   struct msghdr *msg, int size, int flags)
+{
+	struct aa_profile *curr_profile;
+    struct aa_profile *curr_sock_profile;
+	struct aa_profile *sender_profile;
+	struct task_struct *sender;
+	bool allow = true;		
+	__u32 sender_pid;
+	struct aa_sk_ctx *ctx = SK_CTX(sock->sk);
+	char *curr_domain = NULL;
+
+	struct aa_profile *old_profile = aa_get_task_profile(current);
+	curr_profile = aa_get_newest_profile(old_profile);
+	aa_put_profile(old_profile);
+	if(curr_profile != NULL && !unconfined(curr_profile) && ctx != NULL && ctx->profile != NULL)
+	{
+		curr_sock_profile = aa_get_newest_profile(ctx->profile);
+
+		//get the domain from current process profile and not from socket's profile, coz socket's can be passed
+		if(curr_profile->current_domain != NULL && curr_profile->current_domain->domain != NULL)
+        {
+            curr_domain = curr_profile->current_domain->domain;
+        }
+
+		curr_sock_profile->recv_pid = current->pid;
+
+		if (curr_domain != NULL && curr_sock_profile->pid != 0)
+		{
+			if(apparmor_ioctl_debug == 0)
+				printk (KERN_INFO "apparmor_socket_recvmsg (%s): current_pid %d, sk_family=%d, sock->type=%d\n", current->comm, current->pid, sock->sk->sk_family, sock->type);
+			
+			if(sock->sk->sk_family == AF_INET)
+			{
+				
+				sender_pid = curr_sock_profile->pid;
+				// sender = pid_task(find_vpid(sender_pid), PIDTYPE_PID);
+				sender = get_pid_task(find_get_pid(sender_pid), PIDTYPE_PID);
+				if (sender == NULL)
+				{
+					sender_profile = apparmor_tsk_container_get(sender_pid);
+				}
+				else
+				{
+					old_profile = aa_get_task_profile(sender);
+					sender_profile = aa_get_newest_profile(old_profile);
+					aa_put_profile(old_profile);
+				}
+
+				if (sender_profile != NULL)
+				{
+					if (sender_pid != current->pid )
+					{
+						//add sender & receiver profile to cache
+						apparmor_tsk_container_add(curr_profile, current->pid);
+
+                        allow = apparmor_check_for_flow(sender_profile, curr_domain);
+
+						if (allow)
+						{
+							if(apparmor_ioctl_debug == 0)
+								printk (KERN_INFO "[GRAPH_GEN] Process %s, socket_ipc, %s\n", sender_profile->base.hname, curr_profile->base.hname);
+						}
+						if(apparmor_ioctl_debug == 0)
+							printk (KERN_INFO "apparmor_socket_recvmsg (%s): Match is %d for flow from %s(pid = %d) to %s(pid = %d)\n", current->comm, allow, sender_profile->base.hname, sender_pid, current->comm, current->pid);
+					}
+					
+					aa_put_profile(sender_profile);	
+				}
+				else
+				{
+					if(apparmor_ioctl_debug == 0)
+						printk (KERN_INFO "apparmor_socket_recvmsg (%s): else statement for (if (sender_pid != current->pid && sender_label != NULL)) sender pid: %d, current pid: %d\n", current->comm, sender_pid, current->pid);
+				}
+				
+				
+				
+				
+			}//end of if(sock->sk->sk_family == AF_INET )
+			else if(sock->sk->sk_family == AF_UNIX)
+			{
+				if(apparmor_ioctl_debug == 0)
+					printk (KERN_INFO "apparmor_socket_recvmsg: UNIX DOMAIN SOCKET: desti addr = %d, desti port = %d,  sk_rcv_saddr = %d, sk_num = %d, process=%s\n", sock->sk->sk_daddr, 														sock->sk->sk_dport, sock->sk->sk_rcv_saddr, sock->sk->sk_num, current->comm);
+			}
+		} // end for if (curr_domain != NULL)	
+		
+		aa_put_profile(curr_sock_profile);
+	}
+
+	aa_put_profile(curr_profile);
+	if (!allow)
+	{
+		bool drop_flag = false;
+		if(apparmor_ioctl_debug == 0)
+			printk (KERN_INFO "recvmsg (%s): return is -13, status of drop_flag = %d\n", current->comm, drop_flag);
+		return -EACCES;
+	}
+	return 0;
+}
+
+
+
+/**
+ * apparmor_socket_sock_recv_skb - check perms before associating skb to sk
+ *
+ * Note: can not sleep may be called with locks held
+ *
+ * dont want protocol specific in __skb_recv_datagram()
+ * to deny an incoming connection  socket_sock_rcv_skb()
+ */
+static int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	struct aa_sk_ctx *ctx = SK_CTX(sk);
+	struct aa_profile *profile;
+    char *curr_domain = NULL;
+    const struct tcphdr *tcpheader;
+    bool allow = true;
+
+	if (ctx != NULL && ctx->profile != NULL)
+	{
+		profile = aa_get_newest_profile(ctx->profile);
+
+		if(profile->current_domain != NULL && profile->current_domain->domain != NULL)
+        {
+            curr_domain = profile->current_domain->domain;
+        }
+
+		if(curr_domain != NULL && (sk->sk_type == SOCK_STREAM))
+		{
+			tcpheader = tcp_hdr(skb);
+			if (skb->secmark != profile->pid && skb->secmark != 0)
+			{
+				// profile->pid = skb->secmark;
+				allow = apparmor_socket_label_compare(skb->secmark, profile->recv_pid);
+			}
+			if(apparmor_ioctl_debug == 0)
+				printk (KERN_INFO "socket_sock_rcv_skb: TCP socket label_name: %s, profile->pid %d, profile->recv_pid %d, skb->pid %d, skb->data_len %d, syn = %d, ack = %d, fin = %d, allow = %d\n", profile->base.hname, profile->pid, profile->recv_pid, skb->secmark, skb->data_len, tcpheader->syn, tcpheader->ack, tcpheader->fin, allow);
+		}
+
+		else if (curr_domain != NULL && (sk->sk_type == SOCK_DGRAM))
+		{
+			if(apparmor_ioctl_debug == 0)
+				printk (KERN_INFO "apparmor_socket_sock_rcv_skb: UDP socket label_name: %s, profile->pid %d, profile->recv_pid %d, skb->pid %d, skb->data_len %d\n", profile->base.hname, profile->pid, profile->recv_pid, skb->secmark, skb->data_len);
+			// printk (KERN_INFO "skb len %d skb data_len %d\n", skb->len, skb->data_len);
+			allow = apparmor_socket_label_compare(profile->pid, profile->recv_pid);
+		}
+		
+		aa_put_profile(profile);	
+
+        if (!allow)
+        {
+			if(apparmor_ioctl_debug == 0)
+				printk(KERN_INFO "socket_sock_rcv_skb: returning -EACCES\n");
+            return -EACCES;
+        }	
+	}
+	return 0;
+}
+
+
+
+static int apparmor_msg_msg_alloc_security(struct msg_msg *msg)
+{
+	struct aa_msg_queue_ctx *ctx;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	
+	ctx->profile = aa_get_task_profile(current);
+	msg->security = ctx;
+
+	if(apparmor_ioctl_debug == 4)
+		printk(KERN_INFO "msg_alloc: process = %s, profile = %s\n", current->comm, ctx->profile->base.hname);
+
+	return 0;
+}
+
+static void apparmor_msg_msg_free_security(struct msg_msg *msg)
+{
+	struct aa_msg_queue_ctx *ctx = msg->security;
+
+	msg->security = NULL;
+	aa_put_profile(ctx->profile);
+	kfree(ctx);	
+}
+
+static int apparmor_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+			       struct task_struct *target, long type, int mode)
+{	
+	struct aa_profile *sender_profile, *curr_profile;
+	struct aa_msg_queue_ctx *ctx;
+	char *curr_domain = NULL;
+	// @target contains the task structure for recipient process. (from lsm_hooks.h)
+	curr_profile = aa_get_task_profile(target);
+	bool allow = true;
+		
+	if (curr_profile != NULL)
+	{
+		if(apparmor_ioctl_debug == 4)
+			printk (KERN_INFO "apparmor_msg_queue_msgrcv: Current process = %s, target process = %s\n", current->comm, target->comm);
+		if(curr_profile->current_domain != NULL && curr_profile->current_domain->domain != NULL)
+        {
+            curr_domain = curr_profile->current_domain->domain;
+        }
+			
+		if(curr_domain != NULL)
+		{
+			//make it false, so that we knw now its mandatory to perform check
+			allow = false;
+			ctx = msg->security;
+			sender_profile = ctx->profile;
+			if (sender_profile != NULL)
+			{
+				allow = apparmor_check_for_flow(sender_profile, curr_domain);
+				if (allow)
+				{
+					if(apparmor_ioctl_debug == 8)
+						printk (KERN_INFO "[GRAPH_GEN] Process %s, msg_ipc, %s\n", sender_profile->base.hname, curr_profile->base.hname);
+				}
+				else
+				{
+					if(apparmor_ioctl_debug == 4)
+						printk(KERN_INFO "msg_queue_msgrcv: for flow from sender label %s to target NOT ALLOWED\n", sender_profile->base.hname);
+				}
+				
+				aa_put_profile(sender_profile);
+			}
+			else
+			{
+				if(apparmor_ioctl_debug == 4)
+					printk (KERN_INFO "msg_queue_msgrcv: current process = %s, label = %s, sender profile is NULL\n", current->comm, curr_profile->base.hname);
+			}
+			
+		}
+		aa_put_profile(curr_profile);
+	}
+	
+	if (!allow)
+		return -EPERM;
+	return 0;
+}
+
+
+
+static int apparmor_unix_stream_connect(struct sock *sock, struct sock *other,
+					struct sock *newsk)
+{
+	struct aa_sk_ctx *ctx_sender = SK_CTX(sock);
+	struct aa_profile *sender_profile = aa_get_newest_profile(ctx_sender->profile);
+
+	struct aa_sk_ctx *ctx_recv = SK_CTX(other);
+	struct aa_profile *recv_profile = aa_get_newest_profile(ctx_recv->profile);
+
+	char *sender_domain = NULL;
+	char *recv_domain = NULL;
+	bool allow = true;
+
+	if(sender_profile && recv_profile && !unconfined(sender_profile) && !unconfined(recv_profile))
+	{
+		if(apparmor_ioctl_debug == 0)
+			printk (KERN_INFO "apparmor_unix_stream_connect: sender = %s, receiver = %s\n", sender_profile->base.hname, recv_profile->base.hname);
+
+		if(sender_profile->current_domain != NULL && sender_profile->current_domain->domain != NULL)
+		{
+			sender_domain = sender_profile->current_domain->domain;
+		}
+		if(recv_profile->current_domain != NULL && recv_profile->current_domain->domain != NULL)
+		{
+			recv_domain = recv_profile->current_domain->domain;
+		}
+		if (sender_domain && recv_domain)
+		{
+			//make it false, so that we knw now its mandatory to perform check
+			allow = false;
+			allow = apparmor_check_for_flow(sender_profile, recv_domain);
+			if(allow)
+			{
+				if(apparmor_ioctl_debug == 0)
+					printk (KERN_INFO "apparmor_unix_stream_connect: flow from sender_domain %s to recv_domain %s is allowed\n", sender_domain, recv_domain);
+			}
+			else
+			{
+				if(apparmor_ioctl_debug == 0)
+					printk (KERN_INFO "apparmor_unix_stream_connect: flow from sender_domain %s to recv_domain %s is not allowed\n", sender_domain, recv_domain);
+			}
+		}
+		
+
+		
+	}
+	aa_put_profile(sender_profile);
+	aa_put_profile(recv_profile);
+	
+
+	if(!allow)
+	{
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static int apparmor_unix_may_send (struct socket *sock, struct socket *other)
+{
+	struct aa_sk_ctx *ctx_sender = SK_CTX(sock->sk);
+	struct aa_profile *sender_profile = aa_get_newest_profile(ctx_sender->profile);
+
+	struct aa_sk_ctx *ctx_recv = SK_CTX(other->sk);
+	struct aa_profile *recv_profile = aa_get_newest_profile(ctx_recv->profile);
+
+	char *sender_domain = NULL;
+	char *recv_domain = NULL;
+	bool allow = true;
+
+	if(sender_profile && recv_profile && !unconfined(sender_profile) && !unconfined(recv_profile))
+	{
+		if(apparmor_ioctl_debug == 0)
+			printk (KERN_INFO "apparmor_unix_may_send: sender = %s, receiver = %s\n", sender_profile->base.hname, recv_profile->base.hname);
+		if(sender_profile->current_domain != NULL && sender_profile->current_domain->domain != NULL)
+		{
+			sender_domain = sender_profile->current_domain->domain;
+		}
+		if(recv_profile->current_domain != NULL && recv_profile->current_domain->domain != NULL)
+		{
+			recv_domain = recv_profile->current_domain->domain;
+		}
+		if (sender_domain && recv_domain)
+		{
+			//make it false, so that we know now its mandatory to perform check
+			allow = false;
+			allow = apparmor_check_for_flow(sender_profile, recv_domain);
+			if(allow)
+			{
+				if(apparmor_ioctl_debug == 0)
+					printk (KERN_INFO "apparmor_unix_may_send: flow from sender_domain %s to recv_domain %s is allowed\n", sender_domain, recv_domain);
+			}
+			else
+			{
+				if(apparmor_ioctl_debug == 0)
+					printk (KERN_INFO "apparmor_unix_may_send: flow from sender_domain %s to recv_domain %s is not allowed\n", sender_domain, recv_domain);
+			}
+		}
+	}
+
+	aa_put_profile(sender_profile);
+	aa_put_profile(recv_profile);
+	
+
+	if(!allow)
+	{
+		return -EPERM;
+	}
+
+	return 0;
+	
+}
+
+static int apparmor_shm_alloc_security(struct shmid_kernel *shp)
+{
+	struct kern_ipc_perm *perm = &(shp->shm_perm);
+	struct aa_profile *profile = NULL;
+	struct aa_namespace *ns = NULL;
+
+	struct aa_shm_ctx *ctx;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ns = aa_get_namespace((aa_current_profile())->ns);
+	profile = aa_get_profile(ns->unconfined);
+	aa_put_namespace(ns);
+
+	ctx->profile = profile;
+	INIT_LIST_HEAD(&(ctx->proc_attach_list));
+	perm->security = ctx;
+
+	return 0;
+}
+
+static void apparmor_shm_free_security(struct shmid_kernel *shp)
+{
+	struct kern_ipc_perm *perm = &(shp->shm_perm);
+	struct aa_shm_ctx *ctx = perm->security;
+	struct aa_shm_ctx *iterator, *tmp;
+
+	if(apparmor_ioctl_debug == 6)
+		printk(KERN_INFO "shm_free: Iterating list\n");
+	iterator = list_first_entry(&(ctx->proc_attach_list), typeof(*iterator), proc_attach_list);
+	while( (&iterator->proc_attach_list) != &(ctx->proc_attach_list))
+	{
+		if(apparmor_ioctl_debug == 6)
+			printk(KERN_INFO "%s\n", iterator->profile->base.hname);
+		tmp = iterator;
+		iterator = list_next_entry (iterator, proc_attach_list);
+		aa_put_profile(tmp->profile);
+		kzfree(tmp);
+	}
+	if(apparmor_ioctl_debug == 6)
+		printk(KERN_INFO "shm_free: Freed all list nodes\n");
+
+	perm->security = NULL;
+	aa_put_profile(ctx->profile);
+	kfree(ctx);	
+}
+// return true if  current profile is present in shm
+static bool check_profile_exist_in_shm(struct aa_shm_ctx *ctx, char *checking_domain)
+{
+	struct aa_profile *loop_profile;
+	struct aa_shm_ctx *iterator;
+	bool allow = false;
+	
+	iterator = list_first_entry(&(ctx->proc_attach_list), typeof(*iterator), proc_attach_list);
+	while( (&iterator->proc_attach_list) != &(ctx->proc_attach_list))
+	{
+		loop_profile = iterator->profile;
+		if(loop_profile->current_domain != NULL && loop_profile->current_domain->domain != NULL)
+        {
+            if ( strcmp(loop_profile->current_domain->domain, checking_domain) == 0 )
+			{
+				allow = true;
+			}
+        }
+		
+		iterator = list_next_entry (iterator, proc_attach_list);
+	}
+	return allow;
+}
+static int apparmor_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
+{
+	struct kern_ipc_perm *perm = &(shp->shm_perm);
+	struct aa_shm_ctx *ctx = perm->security;
+	struct aa_shm_ctx *iterator;
+
+	struct aa_profile *curr_profile, *loop_profile;
+	char *curr_domain = NULL, *loop_domain = NULL;
+	curr_profile = aa_get_task_profile(current);
+	bool allow = true;
+		
+	if (curr_profile != NULL)
+	{
+		if(curr_profile->current_domain != NULL && curr_profile->current_domain->domain != NULL)
+        {
+            curr_domain = curr_profile->current_domain->domain;
+        }
+			
+		if(curr_domain != NULL)
+		{
+			if(apparmor_ioctl_debug == 6)
+				printk (KERN_INFO "apparmor_shm_shmat: process=%s, label=%s\n", current->comm, curr_domain);
+			
+			//check1: if curr_profile can send msg to all profiles.
+			//check2: if all profiles can send msg to curr_profile
+			iterator = list_first_entry(&(ctx->proc_attach_list), typeof(*iterator), proc_attach_list);
+			while( (&iterator->proc_attach_list) != &(ctx->proc_attach_list))
+			{
+				loop_profile = iterator->profile;
+				loop_profile = aa_get_newest_profile(loop_profile);
+				if(loop_profile->current_domain != NULL && loop_profile->current_domain->domain != NULL)
+				{
+					loop_domain = loop_profile->current_domain->domain;
+					//check1 satisfied
+					//dont check if false, meaning some loop profile and current profile should not send msg
+					if (allow) 
+						allow = apparmor_check_for_flow(curr_profile, loop_domain);	
+				}
+				//check2 satisfied
+				//dont check if false, meaning some loop profile and current profile should not send msg
+				if (allow)
+					allow = apparmor_check_for_flow(loop_profile, curr_domain);
+				
+				
+				iterator = list_next_entry (iterator, proc_attach_list);
+			}
+			if (allow)
+			{
+				// returns true if  current profile is present in shm
+				if (!check_profile_exist_in_shm(ctx, curr_domain))
+				{
+					//curr_domain is not present in shm so add it
+					struct aa_shm_ctx *new_ctx;
+					new_ctx = kzalloc(sizeof(*new_ctx), GFP_KERNEL);
+					if (!new_ctx)
+						goto apparmor_shm_shmat_exit;
+					new_ctx->profile = aa_get_task_profile(current);;
+					list_add(&(new_ctx->proc_attach_list), &(ctx->proc_attach_list));
+					if(apparmor_ioctl_debug == 6)
+						printk (KERN_INFO "apparmor_shm_shmat: new profile added\n");
+				}
+				else
+				{
+					if(apparmor_ioctl_debug == 6)
+						printk (KERN_INFO "apparmor_shm_shmat: profile already exist\n");
+				}
+				
+				
+			}
+			
+		}
+		apparmor_shm_shmat_exit:
+		aa_put_profile(curr_profile);
+	}
+	
+	if (!allow)
+		return -EPERM;
+	return 0;
+}
+
+
+
 static struct security_hook_list apparmor_hooks[] = {
 	LSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),
@@ -601,6 +1980,9 @@
 	LSM_HOOK_INIT(path_chown, apparmor_path_chown),
 	LSM_HOOK_INIT(path_truncate, apparmor_path_truncate),
 	LSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),
+	LSM_HOOK_INIT(inode_alloc_security, apparmor_inode_alloc_security),
+	LSM_HOOK_INIT(inode_free_security, apparmor_inode_free_security),
+	// LSM_HOOK_INIT(inode_init_security, apparmor_inode_init_security),
 
 	LSM_HOOK_INIT(file_open, apparmor_file_open),
 	LSM_HOOK_INIT(file_permission, apparmor_file_permission),
@@ -624,8 +2006,32 @@
 	LSM_HOOK_INIT(bprm_secureexec, apparmor_bprm_secureexec),
 
 	LSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),
+
+	LSM_HOOK_INIT(sk_alloc_security, apparmor_sk_alloc_security),
+	LSM_HOOK_INIT(sk_free_security, apparmor_sk_free_security),
+	LSM_HOOK_INIT(sk_clone_security, apparmor_sk_clone_security),	
+	LSM_HOOK_INIT(socket_post_create, apparmor_socket_post_create),
+	LSM_HOOK_INIT(socket_sendmsg, apparmor_socket_sendmsg),
+	LSM_HOOK_INIT(socket_recvmsg, apparmor_socket_recvmsg),
+	#ifdef CONFIG_NETWORK_SECMARK
+	LSM_HOOK_INIT(socket_sock_rcv_skb, apparmor_socket_sock_rcv_skb),
+	#endif
+
+	LSM_HOOK_INIT(msg_msg_alloc_security, apparmor_msg_msg_alloc_security),
+	LSM_HOOK_INIT(msg_msg_free_security, apparmor_msg_msg_free_security),
+	LSM_HOOK_INIT(msg_queue_msgrcv, apparmor_msg_queue_msgrcv),
+
+	LSM_HOOK_INIT(shm_alloc_security, apparmor_shm_alloc_security),
+	// LSM_HOOK_INIT(ipc_permission, apparmor_ipc_permission),
+	LSM_HOOK_INIT(shm_shmat, apparmor_shm_shmat),
+	LSM_HOOK_INIT(shm_free_security, apparmor_shm_free_security),
+
+	LSM_HOOK_INIT(unix_may_send, apparmor_unix_may_send),
+	LSM_HOOK_INIT(unix_stream_connect, apparmor_unix_stream_connect),
 };
 
+
+
 /*
  * AppArmor sysfs module parameters
  */
@@ -906,4 +2312,130 @@
 	return error;
 }
 
+
+
+
+//Custom ioctl code start
+
+
+long apparmor_debug_flag_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd)
+	{
+		case SET_NETWORK_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: set\n");
+			apparmor_ioctl_debug = 0;
+			break;
+		
+		case CLEAR_NETWORK_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: clear\n");
+			apparmor_ioctl_debug = 1;
+			break;
+		
+		case SET_FILE_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: set\n");
+			apparmor_ioctl_debug = 2;
+			break;
+		
+		case CLEAR_FILE_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: clear\n");
+			apparmor_ioctl_debug = 3;
+			break;
+
+		case SET_MSGQ_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: set\n");
+			apparmor_ioctl_debug = 4;
+			break;
+		
+		case CLEAR_MSGQ_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: clear\n");
+			apparmor_ioctl_debug = 5;
+			break;
+
+		case SET_SHM_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: set\n");
+			apparmor_ioctl_debug = 6;
+			break;
+		
+		case CLEAR_SHM_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: clear\n");
+			apparmor_ioctl_debug = 7;
+			break;
+		
+		case SET_GRAPHGEN_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: set\n");
+			apparmor_ioctl_debug = 8;
+			break;
+		
+		case CLEAR_GRAPHGEN_FLAG:
+
+			// printk_ratelimited(KERN_INFO "debug_flag: clear\n");
+			apparmor_ioctl_debug = 9;
+			break;
+	}
+
+	return 0;
+}
+
+int apparmor_debug_flag_open(struct inode *i, struct file *f)
+{
+	printk_ratelimited(KERN_INFO "debug_flag: Opening device by process %ld\n", (long)(current -> pid));
+    return 0;
+}
+
+int apparmor_debug_flag_close(struct inode *i, struct file *f)
+{
+	printk_ratelimited(KERN_INFO "debug_flag: Closing device by process %ld\n", (long)(current -> pid));
+    return 0;
+}
+
+/*
+ * Map the file operation function pointers to the custom implementations
+ */
+static struct file_operations apparmor_debug_flag_fops = {
+
+	.unlocked_ioctl = apparmor_debug_flag_ioctl,
+	.open = apparmor_debug_flag_open,
+	.release = apparmor_debug_flag_close,
+};
+
+
+/*
+ * Set device parameters
+ */
+static struct miscdevice apparmor_debug_flag_device_ops = {
+
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "debug_flag",
+	.fops = &apparmor_debug_flag_fops,
+};
+
+int __init apparmor_debug_flag_init(void)
+{
+	int ret;
+    ret = misc_register(&apparmor_debug_flag_device_ops);
+	if(ret < 0)
+	{
+		printk_ratelimited(KERN_INFO "debug_flag device registration failed with %d\n", ret);
+	}
+	else
+	{
+		printk_ratelimited(KERN_INFO "debug_flag device successfully registered\n");
+	}
+    return ret;
+}
+
+device_initcall(apparmor_debug_flag_init);
+
+//Custom ioctl code end
+
 security_initcall(apparmor_init);
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/Makefile privaros_kernel/security/apparmor/Makefile
--- kernel-4.9/security/apparmor/Makefile	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/Makefile	2020-08-06 20:11:09.252463666 +0530
@@ -4,7 +4,7 @@
 
 apparmor-y := apparmorfs.o audit.o capability.o context.o ipc.o lib.o match.o \
               path.o domain.o policy.o policy_unpack.o procattr.o lsm.o \
-              resource.o sid.o file.o
+              resource.o sid.o file.o ros_ioctl.o
 apparmor-$(CONFIG_SECURITY_APPARMOR_HASH) += crypto.o
 
 clean-files := capability_names.h rlim_names.h
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/policy_unpack.c privaros_kernel/security/apparmor/policy_unpack.c
--- kernel-4.9/security/apparmor/policy_unpack.c	2020-08-25 22:19:52.583717519 +0530
+++ privaros_kernel/security/apparmor/policy_unpack.c	2020-08-06 20:11:09.252463666 +0530
@@ -510,6 +510,80 @@
 		profile->xmatch_len = tmp;
 	}
 
+	// Custom code : start
+	/* Start of new grammar rules */
+	if (unpack_nameX(e, AA_STRUCT, "DomainMetaData"))
+	{
+		profile->current_domain = kzalloc (sizeof(struct DomainMetaData), GFP_KERNEL);
+		if (!profile->current_domain)
+			goto fail;
+		if(!unpack_strdup(e, &profile->current_domain->domain, NULL))
+			goto fail;
+
+		if (!unpack_u32(e, &(profile->current_domain->allow_cnt), NULL))
+			goto fail;
+		if (!unpack_u32(e, &(profile->current_domain->deny_cnt), NULL))
+			goto fail;
+		if (!unpack_u32(e, &(profile->current_domain->ip_allow_cnt), NULL))
+			goto fail;
+		if (!unpack_nameX(e, AA_STRUCTEND, NULL))
+			goto fail;
+		
+		if (unpack_nameX(e, AA_STRUCT, "AllowedDomains")) 
+		{
+			profile->allow_net_domains = kzalloc(sizeof(struct ListOfDomains), GFP_KERNEL);
+			if (!profile->allow_net_domains)
+				goto fail;
+			INIT_LIST_HEAD(&(profile->allow_net_domains->domain_list));
+
+			for (i = 0; i < profile->current_domain->allow_cnt; i++)
+			{
+				struct ListOfDomains *new_node = kzalloc(sizeof(struct ListOfDomains), GFP_KERNEL);
+				if (!new_node)
+					goto fail;
+				if(!unpack_strdup(e, &new_node->domain, NULL))
+					goto fail;
+
+				INIT_LIST_HEAD(&(new_node->domain_list));
+				list_add(&(new_node->domain_list), &(profile->allow_net_domains->domain_list));
+			}
+			if (!unpack_nameX(e, AA_STRUCTEND, NULL))
+				goto fail;
+		}		
+
+		if (unpack_nameX(e, AA_STRUCT, "AllowedIPAddrs")) 
+		{
+			profile->allowed_ip_addrs = kzalloc(sizeof(struct ListOfIPAddrs), GFP_KERNEL);
+			if (!profile->allowed_ip_addrs)
+				goto fail;
+			INIT_LIST_HEAD(&(profile->allowed_ip_addrs->ip_addr_list));
+			for (i = 0; i < profile->current_domain->ip_allow_cnt; i++)
+			{
+				struct ListOfIPAddrs *new_node = kzalloc(sizeof(struct ListOfIPAddrs), GFP_KERNEL);
+				if (!new_node)
+					goto fail;
+				if(!unpack_u32(e, &new_node->ip_addr, NULL))
+					goto fail;
+
+				INIT_LIST_HEAD(&(new_node->ip_addr_list));
+				list_add(&(new_node->ip_addr_list), &(profile->allowed_ip_addrs->ip_addr_list));
+			}
+			if (!unpack_nameX(e, AA_STRUCTEND, NULL))
+				goto fail;
+		}		
+
+		if (unpack_nameX(e, AA_STRUCT, "ISTrusted")) 
+		{
+			if(!unpack_strdup(e, &profile->is_trusted, NULL))
+				goto fail;
+
+			if (!unpack_nameX(e, AA_STRUCTEND, NULL))
+				goto fail;
+		}
+	}
+	/* End of new grammar rules */
+	// Custom code : end
+
 	/* per profile debug flags (complain, audit) */
 	if (!unpack_nameX(e, AA_STRUCT, "flags"))
 		goto fail;
diff -x '*.git' -x '*.vscode' -ruN kernel-4.9/security/apparmor/ros_ioctl.c privaros_kernel/security/apparmor/ros_ioctl.c
--- kernel-4.9/security/apparmor/ros_ioctl.c	1970-01-01 05:30:00.000000000 +0530
+++ privaros_kernel/security/apparmor/ros_ioctl.c	2020-08-06 20:11:09.252463666 +0530
@@ -0,0 +1,191 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include<linux/slab.h>                 //kmalloc()
+#include<linux/uaccess.h>              //copy_to/from_user()
+#include <linux/ioctl.h>
+
+#include <linux/arm-smccc.h>
+#include <linux/trusty/smcall.h>
+#include <linux/trusty/sm_err.h>
+#include <asm/compiler.h>
+#include <linux/irqflags.h>
+#include <asm/unistd.h>
+
+
+#include <linux/sched.h>
+#include <linux/pid.h>
+#include <linux/pfn.h>
+
+#include "include/apparmor.h"
+#include "include/apparmorfs.h"
+#include "include/audit.h"
+#include "include/capability.h"
+#include "include/context.h"
+#include "include/file.h"
+#include "include/ipc.h"
+#include "include/path.h"
+#include "include/policy.h"
+#include "include/procattr.h"
+
+typedef unsigned long ulong;
+
+
+#define CHECK_IS_TRUSTED _IOR('a','b',int32_t*)
+
+dev_t dev = 0;
+static struct class *dev_class;
+static struct cdev etx_cdev;
+ 
+static int __init etx_driver_init(void);
+static void __exit etx_driver_exit(void);
+static int etx_open(struct inode *inode, struct file *file);
+static int etx_release(struct inode *inode, struct file *file);
+static ssize_t etx_read(struct file *filp, char __user *buf, size_t len,loff_t * off);
+static ssize_t etx_write(struct file *filp, const char *buf, size_t len, loff_t * off);
+static long etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+ 
+static struct file_operations fops =
+{
+        .owner          = THIS_MODULE,
+        .read           = etx_read,
+        .write          = etx_write,
+        .open           = etx_open,
+        .unlocked_ioctl = etx_ioctl,
+        .release        = etx_release,
+};
+ 
+static int etx_open(struct inode *inode, struct file *file)
+{
+        printk(KERN_INFO "Device File Opened...!!!\n");
+        return 0;
+}
+ 
+static int etx_release(struct inode *inode, struct file *file)
+{
+        printk(KERN_INFO "Device File Closed...!!!\n");
+        return 0;
+}
+ 
+static ssize_t etx_read(struct file *filp, char __user *buf, size_t len, loff_t *off)
+{
+        printk(KERN_INFO "Read Function\n");
+        return 0;
+}
+static ssize_t etx_write(struct file *filp, const char __user *buf, size_t len, loff_t *off)
+{
+        printk(KERN_INFO "Write function\n");
+        return 0;
+}
+
+
+
+static long etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd) {
+		case CHECK_IS_TRUSTED:
+                printk(KERN_INFO "Process = %s, arg = %d\n", current->comm, arg); 
+				int return_val = 0; //default is false
+                // copy_from_user(&return_val, (int32_t*)arg, sizeof(int));
+
+                
+                struct aa_profile *curr_profile;
+                struct aa_profile *old_profile = aa_get_task_profile(current);
+                curr_profile = aa_get_newest_profile(old_profile);
+                aa_put_profile(old_profile);
+                if(curr_profile != NULL && !unconfined(curr_profile) )
+                {
+                    if (curr_profile->is_trusted != NULL)
+                    {
+                        printk (KERN_INFO "flag value=%s\n", curr_profile->is_trusted);
+                        if (strcmp(curr_profile->is_trusted, "true") == 0 || strcmp(curr_profile->is_trusted, "True") == 0)
+                        {
+                            return_val = 1;
+                        }
+                    }
+                }
+                else
+                {
+                    printk (KERN_INFO "profile unconfined\n");
+                }
+                printk (KERN_INFO "Value of return_val = %d\n", return_val);
+                aa_put_profile(curr_profile);
+                copy_to_user((int32_t*) arg, &return_val, sizeof(return_val));
+                break;
+        default:
+            break;
+		
+	}
+	return 0;
+}
+
+static char *etx_devnode(struct device *dev, umode_t *mode)
+{
+        if (!mode)
+                return NULL;
+        *mode = 0666;
+        return NULL;
+}
+ 
+static int __init etx_driver_init(void)
+{
+        /*Allocating Major number*/
+        if((alloc_chrdev_region(&dev, 0, 1, "etx_Dev")) <0){
+                printk(KERN_INFO "Cannot allocate major number\n");
+                return -1;
+        }
+        printk(KERN_INFO "Major = %d Minor = %d \n",MAJOR(dev), MINOR(dev));
+ 
+        /*Creating cdev structure*/
+        cdev_init(&etx_cdev,&fops);
+ 
+        /*Adding character device to the system*/
+        if((cdev_add(&etx_cdev,dev,1)) < 0){
+            printk(KERN_INFO "Cannot add the device to the system\n");
+            goto r_class;
+        }
+ 
+        /*Creating struct class*/
+        if((dev_class = class_create(THIS_MODULE,"etx_class")) == NULL){
+            printk(KERN_INFO "Cannot create the struct class\n");
+            goto r_class;
+        }
+        //make this device read without sudo
+        dev_class->devnode = etx_devnode;
+
+        /*Creating device*/
+        if((device_create(dev_class,NULL,dev,NULL,"ros_ioctl_device")) == NULL){
+            printk(KERN_INFO "Cannot create the Device 1\n");
+            goto r_device;
+        }
+        printk(KERN_INFO "Device Driver Insert...Done!!!\n");
+    return 0;
+
+ 
+r_device:
+        class_destroy(dev_class);
+r_class:
+        unregister_chrdev_region(dev,1);
+        return -1;
+}
+ 
+void __exit etx_driver_exit(void)
+{
+    device_destroy(dev_class,dev);
+    class_destroy(dev_class);
+    cdev_del(&etx_cdev);
+    unregister_chrdev_region(dev, 1);
+    printk(KERN_INFO "Device Driver Remove...Done!!!\n");
+}
+
+module_init(etx_driver_init);
+module_exit(etx_driver_exit);
+ 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("CSSL");
+MODULE_DESCRIPTION("ROS IOCTL Call Driver");
+MODULE_VERSION("1");
\ No newline at end of file
